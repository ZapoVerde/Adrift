module,function,lineno,doc
definitions/actor.py,initialize_skill_if_missing,21,
definitions/actor.py,initialize_technique_if_missing,24,
definitions/actor.py,__init__,27,
definitions/actor.py,has_skill,47,Returns True if the actor currently owns the given skill.
definitions/actor.py,has_technique,51,Returns True if the actor has the given technique in their flat cache.
definitions/actor.py,get_technique,55,"Safe accessor for a technique the actor owns.
Raises KeyError if either the skill or technique is missing.

Returns:
    technique_dict (mutable) belonging to this actor"
definitions/actor.py,add_skill,69,"Adds a properly initialized skill block to the actor.

Structure:
    actor.skills[skill_id] = {
        ""level"": 0,
        ""xp"": 0,
        ""visible"": False,
        ""techniques"": {}
    }

Raises:
    ValueError: if the skill_id is not in SKILL_DB"
definitions/actor.py,add_technique,97,"Adds a technique instance to the actor, based on canonical TECHNIQUE_DB.
- Copies the static definition
- Initializes mutations[] and metadata fields
- Registers in both actor.skills[skill][""techniques""] and actor.techniques[tech]

Requires:
    - Skill must already be present

Raises:
    ValueError: if the technique is unknown or the required skill is missing"
definitions/effect.py,__init__,5,
definitions/evolution_offer_generator.py,generate_evolution_offer,15,"Generate a set of mutation options for a technique based on the given skill.
If boost_level > 0, removes lowest rarity tier(s) and adjusts weights accordingly.

Args:
    skill (str): The base skill this offer applies to (e.g. 'sword')
    boost_level (int): 0 (default) = no boost, 1 = skip common, etc.
    current (dict): Existing technique dict to mutate (optional)
    banks (int): If >= 3, includes a boost offer (if not already boosted)

Returns:
    List of dicts, each representing a candidate evolved technique or bank option"
definitions/evolution_offer_generator.py,_generate_base_technique,52,Stub function to generate a technique if none provided.
definitions/faction.py,__init__,5,
definitions/floorplan.py,create_empty_tile,23,"Create a blank tile with default fields.

This function defines the atomic unit of tactical gameplay.
All tiles are assumed to exist in a uniform dict format, with every field explicitly present.
Avoids lazy or implicit defaults to reduce edge-case bugs and enhance testability."
definitions/floorplan.py,create_floorplan,43,"Generate a new floorplan map with initialized tiles.

Floorplans are rectangular regions defined by width and height.
Each tile is prepopulated with a clean state to avoid on-demand logic elsewhere.
The floorplan itself is returned as a dict with metadata and tile dictionary.

Args:
    width: Number of tiles in the horizontal direction
    height: Number of tiles in the vertical direction
    map_id: Unique identifier string for the map instance
    seed: Optional integer seed for map-specific RNG or procedural behavior
    label: Human-readable label, used in UI or debug contexts"
definitions/floorplan.py,get_tile,75,"Retrieve a tile safely from the floorplan.

This wrapper protects against direct dictionary access to allow future logic hooks,
validation, or lazy fallback behavior.

Args:
    floorplan: The full floorplan dictionary
    coord: Tuple (x, y) representing the tile location

Returns:
    Tile dictionary at given coordinates, or None if out-of-bounds."
definitions/floorplan.py,set_tile,92,"Overwrite a tile in the floorplan.

Used to inject modified tiles, e.g., after applying damage or building destruction.
No validation is performed — it assumes tile_data is well-formed.

Args:
    floorplan: Floorplan dict
    coord: (x, y) coordinate
    tile_data: New tile dict to replace existing entry"
definitions/item.py,__init__,5,
definitions/skill.py,__init__,11,
definitions/skill.py,add_xp,19,
definitions/skill.py,add_boost,24,
definitions/skill.py,consume_boost,27,
definitions/skill.py,has_boost,32,
flow/action_flow.py,run_action_phase,9,"Executes the full action phase for an actor, including:
1. Action resolution (stubbed)
2. XP gain based on action tags
3. Automatic technique unlocks
4. Post-action mutation offers"
flow/actor_mutation_flow.py,get_mutation_offer,24,"Generates 4 evolution options for the given skill, factoring in active boost.
Increments history but does not apply anything."
flow/actor_mutation_flow.py,can_offer_boost,46,Returns True if actor has 3+ banked mutations and no current offer boost on skill.
flow/actor_mutation_flow.py,apply_boost,52,Consumes 3 banked mutations to boost rarity of next offer for a given skill.
flow/actor_mutation_flow.py,apply_mutation_choice,65,"Applies a chosen mutation result to the actor.
- If type is 'bank', increments bank.
- Otherwise, applies mutation and resets any skill boost.
- Appends to mutation history."
flow/actor_mutation_flow.py,handle_pending_mutation_offer,88,"Wrapper invoked during the action phase if the actor has a pending offer.
Delegates to the actor's mutation selection logic and applies the result."
flow/actor_mutation_flow.py,handle_post_action_mutation,100,"Checks if any visible technique is eligible for a mutation offer.

- Trigger threshold is probabilistic.
- Stores pending_offer on the actor if triggered."
flow/actor_mutation_flow.py,_boost_level_to_rarity,132,Translates boost level to rarity tier.
flow/dialogue_flow.py,start_dialogue,4,
flow/dialogue_flow.py,advance_dialogue_state,6,
flow/dialogue_flow.py,resolve_dialogue_outcome,8,
flow/encounter_flow.py,detect_encounter,4,
flow/encounter_flow.py,trigger_ambush,6,
flow/engine.py,enter_test_map,31,"Stub function to simulate entering a test tactical map.
Constructs a minimal map instance using dict-based tiles."
flow/exploration_flow.py,resolve_room_entry,4,
flow/exploration_flow.py,handle_travel_command,6,
flow/story_flow.py,check_story_triggers,4,
flow/story_flow.py,fire_story_event,6,
helpers/actor_helpers.py,initialize_skill_if_missing,7,"Adds a new skill block to the actor if it doesn't exist.

Includes all required fields to prevent downstream KeyErrors."
helpers/actor_helpers.py,initialize_technique_if_missing,22,"Adds a technique to the actor's skill block if missing.

Requires that the skill already exist. Initializes all required fields."
helpers/actor_helpers.py,validate_skill_structure,55,
helpers/actor_helpers.py,validate_technique_structure,60,
io/input_handler.py,get_player_input,4,
io/input_handler.py,parse_command,6,
io/messaging.py,queue_room_description,4,
io/messaging.py,queue_entity_sightings,6,
io/messaging.py,queue_player_action_feedback,8,
io/messaging.py,queue_enemy_action_feedback,10,
io/messaging.py,queue_status_effect_messages,12,
io/messaging.py,flush_message_queue,14,
legacy/map.py,__init__,22,
legacy/map.py,get_room,26,Returns a Room object by its internal name.
legacy/map.py,set_starting_room,32,Sets the initial room when the map is first loaded.
legacy/map.py,move_to_room,38,"Moves the current room pointer to a new room.
Assumes caller has validated that the move is allowed."
legacy/tile.py,__init__,8,
libraries/technique_component_library.py,validate_component,112,
libraries/technique_component_library.py,get_all_component_ids,123,
utils/action_utils.py,resolve_walk_action,4,
utils/action_utils.py,resolve_search_action,6,
utils/action_utils.py,resolve_use_action,8,
utils/actor_mutation_utils.py,apply_mutation_to_actor,7,"Applies a selected mutation offer to the actor's technique instance.

Parameters:
    actor: Actor instance
    skill_id: Skill the technique belongs to (e.g., ""melee"", ""sword"")
    technique_id: The canonical technique ID (e.g., ""piercing_thrust"")
    offer: A mutation offer dict, as returned by generate_evolution_offer()

Behavior:
    - Retrieves the actor’s current technique instance
    - Applies the mutation using pure-functional `apply_mutation`
    - Replaces the actor’s stored copy with the mutated result
    - Appends the offer to technique[""mutations""] for traceability"
utils/actor_offer_utils.py,generate_evolution_offer_for_actor,7,"Generates 4 mutation offers for the given actor's technique.

This is a pure function: no state is modified.

Parameters:
    actor: Actor instance
    technique_id: ID of the technique to mutate

Returns:
    List of 4 offer dicts, each with:
        - ""type"": str
        - ""result"": new technique dict (or None for 'bank')"
utils/actor_offer_utils.py,_boost_level_to_rarity,34,Converts integer boost level to a string rarity tier.
utils/combat_utils.py,resolve_attack,4,
utils/combat_utils.py,calculate_damage,6,
utils/combat_utils.py,roll_hit,8,
utils/cover_utils.py,get_cover_objects_along_path,26,"Scans the tiles along the given path and returns all objects that influence cover.

Args:
    path (List[Tuple[int, int]]): List of (x, y) positions from observer to target
    floorplan (Dict): Dict of (x, y): tile

Returns:
    List[Dict]: List of {""pos"": (x, y), ""thing"": <thing dict>} entries that affect cover"
utils/cover_utils.py,calculate_total_cover,48,"Computes the total cover_rating from objects along the path.
Ignores cover that is at the source or destination.

Args:
    path (List[Tuple[int, int]]): Ordered list from observer to target (inclusive)
    floorplan (Dict): Tactical map of tiles

Returns:
    int: Total cover penalty from all intervening things"
utils/debug_utils.py,debug,19,
utils/evasion_utils.py,calculate_visibility,4,
utils/evasion_utils.py,get_stealth_modifier,6,
utils/evolution_offer_utils.py,get_allowed_rarities,13,"Returns the list of allowed rarities after applying boost filtering.

Boost levels:
    0 → all rarities
    1 → uncommon, rare, epic
    2 → rare, epic
    3+ → epic only"
utils/evolution_offer_utils.py,generate_evolution_offer_for_actor,27,"Generates 4 weighted mutation offers for a given actor's visible technique.

Returns list of offer dicts:
    - type
    - skill
    - technique
    - value"
utils/general_utils.py,validate_tags,12,Validates that all tags in a given definition dict exist in TAG_DB.
utils/general_utils.py,validate_all_tags,23,Runs tag validation on both skills and techniques.
utils/general_utils.py,trace_line,31,"Traces a straight line from `start` to `end` using a grid-based algorithm.
Returns a list of dicts, one for each tile crossed, including blocking status.

This function does NOT interpret what counts as blocking — it marks the presence
of potentially blocking features (terrain, things), but leaves interpretation
to the caller.

Parameters:
    - start: origin (x, y)
    - end: destination (x, y)
    - floorplan: map of (x, y) to tile dict
    - stop_at_block: if True, halts trace when blocking tile is encountered

Design constraints:
- No side effects (pure function)
- Supports cardinal and diagonal directions
- Does not skip corners
- Assumes floorplan is prevalidated and includes full tile data for every coord"
utils/general_utils.py,bresenham_line,58,"Bresenham's line algorithm (integer-based, grid-safe)"
utils/general_utils.py,compute_visibility_penalty_along_path,121,"Given a traced path from `trace_line`, compute the cumulative visibility penalty
from all environmental effects (e.g. fog, smoke, fire) on traversed tiles.

This function does not alter the path or interpret vision outcomes — it merely
returns the total penalty value for further evaluation."
utils/initiative_queue.py,initialize_initiative_queue,4,
utils/initiative_queue.py,pop_next_actor,6,
utils/initiative_queue.py,schedule_next_turn,8,
utils/inventory_utils.py,add_item_to_inventory,4,
utils/inventory_utils.py,remove_item_from_inventory,6,
utils/inventory_utils.py,is_item_usable,8,
utils/loot_utils.py,roll_loot_table,4,
utils/loot_utils.py,drop_loot_to_room,6,
utils/movement_utils.py,move_actor_to_zone,28,"🚶 Low-level zone transition function. Moves an actor from their current
zone to an *adjacent* zone, with full validation.

This is the core atomic movement step, and is used by all higher-level
movement logic. It ensures:
- The destination zone is adjacent to the current one
- The actor is removed from the old zone and added to the new one
- The actor's `current_zone` reference is updated

Parameters:
- actor: any object with `.name` and `.current_zone`
- destination_zone: Zone object

Returns:
- True if move succeeds
- False if destination is not adjacent"
utils/movement_utils.py,get_zone_by_feature,68,"Resolves a string like ""broken pillar"" or ""pile of crates""
to the first Zone in the room that contains that feature.

Parameters:
- room: Room object containing zones
- feature_string: exact string to match in zone.features

Returns:
- Zone object if found
- None if not found"
utils/movement_utils.py,resolve_target_to_zone,88,"Resolves any navigation target to a Zone.

Accepted target types:
- str: treated as a feature name
- any object with `.current_zone`: treated as an actor

Parameters:
- target: str or actor object
- room: Room object used for feature resolution

Returns:
- Zone object or None"
utils/movement_utils.py,find_path_between_zones,114,"Returns a list of zones connecting start_zone to target_zone
using breadth-first search.

This allows navigation across multi-zone rooms based on connectivity.

Returns:
- List of Zone objects [start, ..., target]
- Empty list if no valid path exists"
utils/movement_utils.py,distance_between_zones,150,"Returns the number of hops between two zones using breadth-first search.
If no path exists (e.g. blocked or disconnected), returns None."
utils/movement_utils.py,move_actor_toward_target,179,"Generalized movement function that handles:
- Moving toward a feature (str)
- Moving toward another actor

It resolves the target to a destination zone, computes the shortest
path from the actor's current zone, and moves one step toward it.

This enables natural language-style inputs:
- ""move to pile of crates""
- ""approach the automaton""

Movement is only one step per call to enforce tactical pacing.

Parameters:
- actor: object with .name and .current_zone
- room: Room object the actor is in
- target: str (feature) or object with .current_zone

Returns:
- True if movement occurred
- False if move invalid, unreachable, or already there"
utils/movement_utils.py,start_movement_to_target,220,"Initializes multi-turn movement toward a feature or actor.
Stores the zone path in actor.movement_path.

This replaces immediate movement — nothing happens this turn,
but actor is now committed to a path.

Parameters:
- actor: actor object
- room: the current Room
- target: feature string or another actor

Returns:
- True if movement path created
- False if target invalid or unreachable"
utils/movement_utils.py,advance_actor_movement,252,"Advances movement along actor's movement_path by one turn.
- Adds 1 to progress
- Moves to next zone when cost is met
- Resets progress
- Continues until path is empty

Returns:
- True if actor moved to a new zone this turn
- False if still progressing or path empty"
utils/npc_ai.py,handle_npc_action,4,
utils/npc_ai.py,choose_npc_action,6,
utils/npc_ai.py,npc_can_see_player,8,
utils/skill_xp_utils.py,track_xp_gain,7,"Distributes XP to matching skills and techniques.

Automatically initializes skills/techniques if needed.

XP gain is flat per success. Level-up is probabilistic."
utils/skill_xp_utils.py,_tags_match,45,Returns True if any of the required tags are found in the observed list.
utils/skill_xp_utils.py,_check_level_up,56,"Performs a probabilistic level-up check for the given skill or technique block.
XP is preserved. Visibility is granted on first level."
utils/skills_utils.py,tick_skill_progression,4,
utils/skills_utils.py,get_skill_modifier,6,
utils/skills_utils.py,add_skill_xp,8,
utils/status_effects.py,apply_status_effects,4,
utils/status_effects.py,tick_status_effects,6,
utils/status_effects.py,add_effect,8,
utils/technique_mutation_utils.py,generate_evolution_offer,12,"Given a technique dict, returns 4 possible evolution choices:
- Add effect (if legal)
- Replace effect
- Change modifier (if any)
- Bank offer

The rarity parameter influences the subcomponent weights."
utils/technique_mutation_utils.py,available_effects,25,
utils/technique_mutation_utils.py,apply_mutation,62,"Applies the selected mutation offer to the base technique.

Arguments:
    base_technique: The original technique dict before mutation.
    offer: A dict containing keys:
        - ""type"": One of ""replace_effect"", ""add_effect"", ""change_modifier"", ""bank""
        - ""result"": The precomputed result technique (except for ""bank"")

Returns:
    A new technique dict reflecting the chosen mutation.
    If type == ""bank"", returns the original technique unchanged."
utils/technique_unlock_utils.py,auto_unlock_techniques,7,"Scans canonical techniques and adds any to the actor whose
base_skill has reached its level_required."
utils/technique_utils.py,generate_technique,12,Generate a base technique scaffold with random components for a given skill.
utils/technique_utils.py,evolve_replace_effect,36,"Replaces the first effect with a different one from the effect pool.
Guarantees a change if at least 2 effects exist.
Skips if same replacement already applied."
utils/technique_utils.py,evolve_add_modifier,69,Adds a new modifier from the pool. Does nothing if already added.
utils/technique_utils.py,evolve_add_effect,91,Adds a new effect if not already present and not already added before.
utils/technique_utils.py,evolve_technique,122,"Dispatches to the correct mutation function for test scaffolding.
Not intended for runtime use."
utils/technique_utils.py,get_available_mutations,141,"Returns a list of valid mutation types for a given technique.

Ensures we do not suggest evolutions that would exceed field limits
or create invalid states. Used by the mutation offer generator.

Possible mutations:
- ""replace_effect"": always allowed if any effect exists
- ""add_effect"": allowed if len(effects) < 2
- ""add_modifier"": only allowed if modifier is None"
utils/test_trace_line.py,make_blank_tile,6,
utils/test_trace_line.py,test_straight_line_unblocked,9,
utils/test_trace_line.py,test_diagonal_line_with_blocking_tile,17,
utils/test_trace_line.py,test_tile_with_blocking_thing,27,
utils/test_trace_line.py,test_missing_tile_skipped,34,
utils/test_visibility_penalty.py,make_tile_with_env,6,"Helper: create tile with list of env objects, each with a visibility_penalty."
utils/test_visibility_penalty.py,test_no_environment_penalty,14,
utils/test_visibility_penalty.py,test_single_fog_tile,19,
utils/test_visibility_penalty.py,test_multiple_penalty_sources,28,
utils/test_visibility_penalty.py,test_missing_env_field,37,
utils/test_visibility_penalty.py,test_empty_path,46,
utils/test_visibility_penalty.py,test_invalid_path_type,49,
utils/test_visibility_penalty.py,test_step_not_dict,53,
utils/test_visibility_penalty.py,test_missing_tile_dict,57,
utils/test_visibility_penalty.py,test_env_not_list,61,
utils/visibility_utils.py,get_visibility_caps,8,"Returns (max_clear, max_vague) based on light level.
Includes overexposure collapse at high intensity."
utils/visibility_utils.py,visual_coverage,37,"Estimate how much of the target zone is visible from the observer.
Uses number of blocking zones along the visibility path as a proxy for visual obstruction.

Returns a float between 0.0 and 1.0:
- >= 0.9 → clear visibility
- >= 0.3 → vague
- < 0.3 → unseen"
utils/visibility_utils.py,observe,59,"Perception scan with:
- Light-based visibility caps
- Vague fallback awareness
- Tiered resolution: clear, vague, or unknown"
utils/visibility_utils.py,trace_visibility_path,150,"Returns the list of intermediate zones (excluding origin and target)
along the shortest line-of-vision path between origin and target.
This is a vision-safe BFS path that ignores movement-specific obstacles.

If no path is found (e.g. disconnected zones), returns None."
utils/visibility_utils.py,compute_visibility_penalty_along_path,182,
utils/world_utils.py,get_all_actors_in_room,4,
utils/world_utils.py,remove_dead_entities,6,
utils/world_utils.py,transfer_loot_to_room,8,
world/discovery.py,__init__,8,
world/discovery.py,reveal,15,
world/discovery.py,instantiate,19,
world/discovery.py,__init__,24,
world/discovery.py,generate_floorplan,32,
world/discovery.py,teardown,35,
world/generation.py,__init__,8,
world/generation.py,generate_tile,11,
world/generation.py,sample_biome,18,
world/generation.py,sample_elevation,21,
world/generation.py,sample_moisture,24,
world/generation.py,sample_features,27,
world/hex.py,__init__,8,
world/hex.py,generate_seed,20,
world/hex.py,coord,23,
