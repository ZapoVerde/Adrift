# core/debug_utils.py
# [AI]
# [PERMANENT]
# Generated by assistant under integrator review
# Must follow locked contracts and tagging rules

"""Provides structured debug logging with JSON output and MECE-tag validation.
All runtime output is written to debug_logs/*.jsonl using tagged, traceable payloads.

@tags: ["system", "event_data", "runtime_behavior", "always"]
@status: "permanent"
"""

import os
import uuid
import json
import datetime
from typing import Optional, Any
from config.config import DEBUG_MODE

# Root directory for all logs (must exist in project root)
LOG_DIR = "debug_logs"

# Internal helper: builds full file path from context
# @tags: ["system", "event_data", "data_schema", "always"]
def _get_log_path(context: str) -> str:
    return os.path.join(LOG_DIR, context.replace("/", "_") + ".jsonl")

# Internal helper: emits one JSON object per line
# @tags: ["system", "event_data", "data_schema", "always"]
def _emit_log(payload: dict, path: str):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "a", encoding="utf-8") as f:
        f.write(json.dumps(payload) + "\n")

# Public debug interface: returns a logger bound to a specific context
# @tags: ["system", "event_data", "runtime_behavior", "always"]
def get_debugger(context: str):
    """Creates a context-bound debug emitter that logs JSONL to debug_logs/.

    @tags: ["system", "event_data", "runtime_behavior", "always"]
    @status: "permanent"
    """
    def _debug(
        action: str,
        data: Optional[dict] = None,
        state: Optional[dict] = None,
        trace_id: Optional[str] = None,
        ai_tags: Optional[list] = None,
        print_console: bool = False
    ):
        payload: dict[str, Any] = {
        "timestamp": datetime.datetime.utcnow().isoformat(),
        "context": context,
        "action": action,
        "trace_id": trace_id or str(uuid.uuid4()),
        }
        if data:
            payload["data"] = data
        if state:
            payload["state"] = state
        if ai_tags:
            payload["ai_tags"] = ai_tags

        if not ai_tags or not isinstance(ai_tags, list) or len(ai_tags) < 4:
            raise ValueError(f"Missing or malformed ai_tags: {ai_tags}")

        log_path = _get_log_path(context)
        if DEBUG_MODE:
            _emit_log(payload, log_path)
        if print_console:
            print(f"[{context}] {action} | {payload}")

    return _debug
