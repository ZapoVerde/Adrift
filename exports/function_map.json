[
  {
    "module": "definitions/actor.py",
    "name": "add_skill",
    "lineno": 69,
    "args": [
      "actor",
      "skill_id"
    ],
    "doc": "Adds a properly initialized skill block to the actor.\n\nStructure:\n    actor.skills[skill_id] = {\n        \"level\": 0,\n        \"xp\": 0,\n        \"visible\": False,\n        \"techniques\": {}\n    }\n\nRaises:\n    ValueError: if the skill_id is not in SKILL_DB",
    "calls": [
      "ValueError"
    ],
    "called_by": []
  },
  {
    "module": "definitions/actor.py",
    "name": "add_technique",
    "lineno": 97,
    "args": [
      "actor",
      "tech_id"
    ],
    "doc": "Adds a technique instance to the actor, based on canonical TECHNIQUE_DB.\n- Copies the static definition\n- Initializes mutations[] and metadata fields\n- Registers in both actor.skills[skill][\"techniques\"] and actor.techniques[tech]\n\nRequires:\n    - Skill must already be present\n\nRaises:\n    ValueError: if the technique is unknown or the required skill is missing",
    "calls": [
      "ValueError",
      "deepcopy",
      "get"
    ],
    "called_by": [
      "auto_unlock_techniques"
    ]
  },
  {
    "module": "definitions/actor.py",
    "name": "initialize_skill_if_missing",
    "lineno": 21,
    "args": [
      "self",
      "skill_id"
    ],
    "doc": "",
    "calls": [
      "initialize_skill_if_missing"
    ],
    "called_by": [
      "initialize_skill_if_missing",
      "track_xp_gain"
    ]
  },
  {
    "module": "definitions/actor.py",
    "name": "initialize_technique_if_missing",
    "lineno": 24,
    "args": [
      "self",
      "skill_id",
      "tech_id"
    ],
    "doc": "",
    "calls": [
      "initialize_technique_if_missing"
    ],
    "called_by": [
      "initialize_technique_if_missing",
      "track_xp_gain"
    ]
  },
  {
    "module": "definitions/actor.py",
    "name": "__init__",
    "lineno": 27,
    "args": [
      "self",
      "name",
      "current_zone"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/actor.py",
    "name": "has_skill",
    "lineno": 47,
    "args": [
      "self",
      "skill_id"
    ],
    "doc": "Returns True if the actor currently owns the given skill.",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/actor.py",
    "name": "has_technique",
    "lineno": 51,
    "args": [
      "self",
      "tech_id"
    ],
    "doc": "Returns True if the actor has the given technique in their flat cache.",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/actor.py",
    "name": "get_technique",
    "lineno": 55,
    "args": [
      "self",
      "skill_id",
      "tech_id"
    ],
    "doc": "Safe accessor for a technique the actor owns.\nRaises KeyError if either the skill or technique is missing.\n\nReturns:\n    technique_dict (mutable) belonging to this actor",
    "calls": [
      "KeyError"
    ],
    "called_by": []
  },
  {
    "module": "definitions/effect.py",
    "name": "__init__",
    "lineno": 5,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/evolution_offer_generator.py",
    "name": "generate_evolution_offer",
    "lineno": 15,
    "args": [
      "skill",
      "boost_level",
      "current",
      "banks"
    ],
    "doc": "Generate a set of mutation options for a technique based on the given skill.\nIf boost_level > 0, removes lowest rarity tier(s) and adjusts weights accordingly.\n\nArgs:\n    skill (str): The base skill this offer applies to (e.g. 'sword')\n    boost_level (int): 0 (default) = no boost, 1 = skip common, etc.\n    current (dict): Existing technique dict to mutate (optional)\n    banks (int): If >= 3, includes a boost offer (if not already boosted)\n\nReturns:\n    List of dicts, each representing a candidate evolved technique or bank option",
    "calls": [
      "_generate_base_technique",
      "append",
      "copy",
      "evolve_technique"
    ],
    "called_by": [
      "generate_evolution_offer_for_actor",
      "get_mutation_offer"
    ]
  },
  {
    "module": "definitions/evolution_offer_generator.py",
    "name": "_generate_base_technique",
    "lineno": 52,
    "args": [
      "skill"
    ],
    "doc": "Stub function to generate a technique if none provided.",
    "calls": [
      "generate_technique"
    ],
    "called_by": [
      "generate_evolution_offer"
    ]
  },
  {
    "module": "definitions/faction.py",
    "name": "__init__",
    "lineno": 5,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/floorplan.py",
    "name": "create_empty_tile",
    "lineno": 23,
    "args": [],
    "doc": "Create a blank tile with default fields.\n\nThis function defines the atomic unit of tactical gameplay.\nAll tiles are assumed to exist in a uniform dict format, with every field explicitly present.\nAvoids lazy or implicit defaults to reduce edge-case bugs and enhance testability.",
    "calls": [],
    "called_by": [
      "create_floorplan"
    ]
  },
  {
    "module": "definitions/floorplan.py",
    "name": "create_floorplan",
    "lineno": 43,
    "args": [
      "width",
      "height",
      "map_id",
      "seed",
      "label"
    ],
    "doc": "Generate a new floorplan map with initialized tiles.\n\nFloorplans are rectangular regions defined by width and height.\nEach tile is prepopulated with a clean state to avoid on-demand logic elsewhere.\nThe floorplan itself is returned as a dict with metadata and tile dictionary.\n\nArgs:\n    width: Number of tiles in the horizontal direction\n    height: Number of tiles in the vertical direction\n    map_id: Unique identifier string for the map instance\n    seed: Optional integer seed for map-specific RNG or procedural behavior\n    label: Human-readable label, used in UI or debug contexts",
    "calls": [
      "create_empty_tile",
      "range"
    ],
    "called_by": [
      "enter_test_map"
    ]
  },
  {
    "module": "definitions/floorplan.py",
    "name": "get_tile",
    "lineno": 75,
    "args": [
      "floorplan",
      "coord"
    ],
    "doc": "Retrieve a tile safely from the floorplan.\n\nThis wrapper protects against direct dictionary access to allow future logic hooks,\nvalidation, or lazy fallback behavior.\n\nArgs:\n    floorplan: The full floorplan dictionary\n    coord: Tuple (x, y) representing the tile location\n\nReturns:\n    Tile dictionary at given coordinates, or None if out-of-bounds.",
    "calls": [
      "get"
    ],
    "called_by": [
      "enter_test_map"
    ]
  },
  {
    "module": "definitions/floorplan.py",
    "name": "set_tile",
    "lineno": 92,
    "args": [
      "floorplan",
      "coord",
      "tile_data"
    ],
    "doc": "Overwrite a tile in the floorplan.\n\nUsed to inject modified tiles, e.g., after applying damage or building destruction.\nNo validation is performed \u2014 it assumes tile_data is well-formed.\n\nArgs:\n    floorplan: Floorplan dict\n    coord: (x, y) coordinate\n    tile_data: New tile dict to replace existing entry",
    "calls": [],
    "called_by": [
      "enter_test_map"
    ]
  },
  {
    "module": "definitions/item.py",
    "name": "__init__",
    "lineno": 5,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/skill.py",
    "name": "__init__",
    "lineno": 11,
    "args": [
      "self",
      "skill_id"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/skill.py",
    "name": "add_xp",
    "lineno": 19,
    "args": [
      "self",
      "amount"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/skill.py",
    "name": "add_boost",
    "lineno": 24,
    "args": [
      "self",
      "count"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/skill.py",
    "name": "consume_boost",
    "lineno": 27,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "definitions/skill.py",
    "name": "has_boost",
    "lineno": 32,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/action_flow.py",
    "name": "run_action_phase",
    "lineno": 9,
    "args": [
      "actor",
      "context"
    ],
    "doc": "Executes the full action phase for an actor, including:\n1. Action resolution (stubbed)\n2. XP gain based on action tags\n3. Automatic technique unlocks\n4. Post-action mutation offers",
    "calls": [
      "auto_unlock_techniques",
      "get",
      "handle_post_action_mutation",
      "track_xp_gain"
    ],
    "called_by": []
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "get_mutation_offer",
    "lineno": 24,
    "args": [
      "actor",
      "skill"
    ],
    "doc": "Generates 4 evolution options for the given skill, factoring in active boost.\nIncrements history but does not apply anything.",
    "calls": [
      "_boost_level_to_rarity",
      "generate_evolution_offer",
      "get"
    ],
    "called_by": []
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "can_offer_boost",
    "lineno": 46,
    "args": [
      "actor",
      "skill"
    ],
    "doc": "Returns True if actor has 3+ banked mutations and no current offer boost on skill.",
    "calls": [
      "get"
    ],
    "called_by": [
      "apply_boost"
    ]
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "apply_boost",
    "lineno": 52,
    "args": [
      "actor",
      "skill"
    ],
    "doc": "Consumes 3 banked mutations to boost rarity of next offer for a given skill.",
    "calls": [
      "ValueError",
      "can_offer_boost",
      "setdefault"
    ],
    "called_by": []
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "apply_mutation_choice",
    "lineno": 65,
    "args": [
      "actor",
      "skill",
      "choice"
    ],
    "doc": "Applies a chosen mutation result to the actor.\n- If type is 'bank', increments bank.\n- Otherwise, applies mutation and resets any skill boost.\n- Appends to mutation history.",
    "calls": [
      "append",
      "get",
      "pop",
      "setdefault"
    ],
    "called_by": [
      "handle_pending_mutation_offer"
    ]
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "handle_pending_mutation_offer",
    "lineno": 88,
    "args": [
      "actor",
      "context"
    ],
    "doc": "Wrapper invoked during the action phase if the actor has a pending offer.\nDelegates to the actor's mutation selection logic and applies the result.",
    "calls": [
      "apply_mutation_choice",
      "get",
      "select_mutation_option"
    ],
    "called_by": []
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "handle_post_action_mutation",
    "lineno": 100,
    "args": [
      "actor"
    ],
    "doc": "Checks if any visible technique is eligible for a mutation offer.\n\n- Trigger threshold is probabilistic.\n- Stores pending_offer on the actor if triggered.",
    "calls": [
      "generate_evolution_offer_for_actor",
      "get",
      "getattr",
      "items",
      "random"
    ],
    "called_by": [
      "run_action_phase"
    ]
  },
  {
    "module": "flow/actor_mutation_flow.py",
    "name": "_boost_level_to_rarity",
    "lineno": 132,
    "args": [
      "boost_level"
    ],
    "doc": "Translates boost level to rarity tier.",
    "calls": [],
    "called_by": [
      "generate_evolution_offer_for_actor",
      "get_mutation_offer"
    ]
  },
  {
    "module": "flow/dialogue_flow.py",
    "name": "start_dialogue",
    "lineno": 4,
    "args": [
      "npc",
      "player"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/dialogue_flow.py",
    "name": "advance_dialogue_state",
    "lineno": 6,
    "args": [
      "npc",
      "choice"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/dialogue_flow.py",
    "name": "resolve_dialogue_outcome",
    "lineno": 8,
    "args": [
      "npc",
      "player"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/encounter_flow.py",
    "name": "detect_encounter",
    "lineno": 4,
    "args": [
      "actor",
      "visible_entities"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/encounter_flow.py",
    "name": "trigger_ambush",
    "lineno": 6,
    "args": [
      "enemy",
      "player"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/engine.py",
    "name": "enter_test_map",
    "lineno": 31,
    "args": [],
    "doc": "Stub function to simulate entering a test tactical map.\nConstructs a minimal map instance using dict-based tiles.",
    "calls": [
      "create_floorplan",
      "get_tile",
      "set_tile"
    ],
    "called_by": []
  },
  {
    "module": "flow/exploration_flow.py",
    "name": "resolve_room_entry",
    "lineno": 4,
    "args": [
      "player",
      "room"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/exploration_flow.py",
    "name": "handle_travel_command",
    "lineno": 6,
    "args": [
      "command"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/story_flow.py",
    "name": "check_story_triggers",
    "lineno": 4,
    "args": [
      "state"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "flow/story_flow.py",
    "name": "fire_story_event",
    "lineno": 6,
    "args": [
      "event_id"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "helpers/actor_helpers.py",
    "name": "initialize_skill_if_missing",
    "lineno": 7,
    "args": [
      "actor",
      "skill_id"
    ],
    "doc": "Adds a new skill block to the actor if it doesn't exist.\n\nIncludes all required fields to prevent downstream KeyErrors.",
    "calls": [],
    "called_by": [
      "initialize_skill_if_missing",
      "track_xp_gain"
    ]
  },
  {
    "module": "helpers/actor_helpers.py",
    "name": "initialize_technique_if_missing",
    "lineno": 22,
    "args": [
      "actor",
      "skill_id",
      "tech_id"
    ],
    "doc": "Adds a technique to the actor's skill block if missing.\n\nRequires that the skill already exist. Initializes all required fields.",
    "calls": [
      "ValueError",
      "get"
    ],
    "called_by": [
      "initialize_technique_if_missing",
      "track_xp_gain"
    ]
  },
  {
    "module": "helpers/actor_helpers.py",
    "name": "validate_skill_structure",
    "lineno": 55,
    "args": [
      "skill_block"
    ],
    "doc": "",
    "calls": [
      "issubset"
    ],
    "called_by": []
  },
  {
    "module": "helpers/actor_helpers.py",
    "name": "validate_technique_structure",
    "lineno": 60,
    "args": [
      "tech_block"
    ],
    "doc": "",
    "calls": [
      "issubset"
    ],
    "called_by": []
  },
  {
    "module": "io/input_handler.py",
    "name": "get_player_input",
    "lineno": 4,
    "args": [],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/input_handler.py",
    "name": "parse_command",
    "lineno": 6,
    "args": [
      "raw_input"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "queue_room_description",
    "lineno": 4,
    "args": [
      "room"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "queue_entity_sightings",
    "lineno": 6,
    "args": [
      "entities"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "queue_player_action_feedback",
    "lineno": 8,
    "args": [
      "command"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "queue_enemy_action_feedback",
    "lineno": 10,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "queue_status_effect_messages",
    "lineno": 12,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "io/messaging.py",
    "name": "flush_message_queue",
    "lineno": 14,
    "args": [],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "legacy/map.py",
    "name": "__init__",
    "lineno": 22,
    "args": [
      "self",
      "rooms"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "legacy/map.py",
    "name": "get_room",
    "lineno": 26,
    "args": [
      "self",
      "internal_name"
    ],
    "doc": "Returns a Room object by its internal name.",
    "calls": [
      "get"
    ],
    "called_by": []
  },
  {
    "module": "legacy/map.py",
    "name": "set_starting_room",
    "lineno": 32,
    "args": [
      "self",
      "internal_name"
    ],
    "doc": "Sets the initial room when the map is first loaded.",
    "calls": [
      "get"
    ],
    "called_by": []
  },
  {
    "module": "legacy/map.py",
    "name": "move_to_room",
    "lineno": 38,
    "args": [
      "self",
      "internal_name"
    ],
    "doc": "Moves the current room pointer to a new room.\nAssumes caller has validated that the move is allowed.",
    "calls": [],
    "called_by": []
  },
  {
    "module": "legacy/tile.py",
    "name": "__init__",
    "lineno": 8,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "libraries/technique_component_library.py",
    "name": "validate_component",
    "lineno": 112,
    "args": [
      "comp"
    ],
    "doc": "",
    "calls": [
      "isinstance",
      "issubset",
      "keys",
      "set"
    ],
    "called_by": []
  },
  {
    "module": "libraries/technique_component_library.py",
    "name": "get_all_component_ids",
    "lineno": 123,
    "args": [],
    "doc": "",
    "calls": [
      "extend",
      "keys",
      "values"
    ],
    "called_by": []
  },
  {
    "module": "utils/action_utils.py",
    "name": "resolve_walk_action",
    "lineno": 4,
    "args": [
      "player",
      "direction"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/action_utils.py",
    "name": "resolve_search_action",
    "lineno": 6,
    "args": [
      "player"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/action_utils.py",
    "name": "resolve_use_action",
    "lineno": 8,
    "args": [
      "player",
      "item"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/actor_mutation_utils.py",
    "name": "apply_mutation_to_actor",
    "lineno": 7,
    "args": [
      "actor",
      "skill_id",
      "technique_id",
      "offer"
    ],
    "doc": "Applies a selected mutation offer to the actor's technique instance.\n\nParameters:\n    actor: Actor instance\n    skill_id: Skill the technique belongs to (e.g., \"melee\", \"sword\")\n    technique_id: The canonical technique ID (e.g., \"piercing_thrust\")\n    offer: A mutation offer dict, as returned by generate_evolution_offer()\n\nBehavior:\n    - Retrieves the actor\u2019s current technique instance\n    - Applies the mutation using pure-functional `apply_mutation`\n    - Replaces the actor\u2019s stored copy with the mutated result\n    - Appends the offer to technique[\"mutations\"] for traceability",
    "calls": [
      "ValueError",
      "append",
      "apply_mutation",
      "get",
      "setdefault"
    ],
    "called_by": []
  },
  {
    "module": "utils/actor_offer_utils.py",
    "name": "generate_evolution_offer_for_actor",
    "lineno": 7,
    "args": [
      "actor",
      "technique_id"
    ],
    "doc": "Generates 4 mutation offers for the given actor's technique.\n\nThis is a pure function: no state is modified.\n\nParameters:\n    actor: Actor instance\n    technique_id: ID of the technique to mutate\n\nReturns:\n    List of 4 offer dicts, each with:\n        - \"type\": str\n        - \"result\": new technique dict (or None for 'bank')",
    "calls": [
      "ValueError",
      "_boost_level_to_rarity",
      "generate_evolution_offer",
      "get"
    ],
    "called_by": [
      "handle_post_action_mutation"
    ]
  },
  {
    "module": "utils/actor_offer_utils.py",
    "name": "_boost_level_to_rarity",
    "lineno": 34,
    "args": [
      "boost_level"
    ],
    "doc": "Converts integer boost level to a string rarity tier.",
    "calls": [],
    "called_by": [
      "generate_evolution_offer_for_actor",
      "get_mutation_offer"
    ]
  },
  {
    "module": "utils/combat_utils.py",
    "name": "resolve_attack",
    "lineno": 4,
    "args": [
      "attacker",
      "target"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/combat_utils.py",
    "name": "calculate_damage",
    "lineno": 6,
    "args": [
      "weapon",
      "attacker",
      "target"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/combat_utils.py",
    "name": "roll_hit",
    "lineno": 8,
    "args": [
      "attacker",
      "target"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/cover_utils.py",
    "name": "get_cover_objects_along_path",
    "lineno": 26,
    "args": [
      "path",
      "floorplan"
    ],
    "doc": "Scans the tiles along the given path and returns all objects that influence cover.\n\nArgs:\n    path (List[Tuple[int, int]]): List of (x, y) positions from observer to target\n    floorplan (Dict): Dict of (x, y): tile\n\nReturns:\n    List[Dict]: List of {\"pos\": (x, y), \"thing\": <thing dict>} entries that affect cover",
    "calls": [
      "append",
      "get"
    ],
    "called_by": [
      "calculate_total_cover"
    ]
  },
  {
    "module": "utils/cover_utils.py",
    "name": "calculate_total_cover",
    "lineno": 48,
    "args": [
      "path",
      "floorplan"
    ],
    "doc": "Computes the total cover_rating from objects along the path.\nIgnores cover that is at the source or destination.\n\nArgs:\n    path (List[Tuple[int, int]]): Ordered list from observer to target (inclusive)\n    floorplan (Dict): Tactical map of tiles\n\nReturns:\n    int: Total cover penalty from all intervening things",
    "calls": [
      "get",
      "get_cover_objects_along_path",
      "isinstance",
      "len",
      "sum"
    ],
    "called_by": []
  },
  {
    "module": "utils/debug_utils.py",
    "name": "debug",
    "lineno": 19,
    "args": [
      "message"
    ],
    "doc": "",
    "calls": [
      "print",
      "replace",
      "split",
      "stack",
      "upper"
    ],
    "called_by": [
      "advance_actor_movement",
      "find_path_between_zones",
      "get_zone_by_feature",
      "move_actor_to_zone",
      "move_actor_toward_target",
      "observe",
      "resolve_target_to_zone",
      "start_movement_to_target"
    ]
  },
  {
    "module": "utils/evasion_utils.py",
    "name": "calculate_visibility",
    "lineno": 4,
    "args": [
      "actor",
      "observer"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/evasion_utils.py",
    "name": "get_stealth_modifier",
    "lineno": 6,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/evolution_offer_utils.py",
    "name": "get_allowed_rarities",
    "lineno": 13,
    "args": [
      "boost"
    ],
    "doc": "Returns the list of allowed rarities after applying boost filtering.\n\nBoost levels:\n    0 \u2192 all rarities\n    1 \u2192 uncommon, rare, epic\n    2 \u2192 rare, epic\n    3+ \u2192 epic only",
    "calls": [
      "min"
    ],
    "called_by": [
      "generate_evolution_offer_for_actor"
    ]
  },
  {
    "module": "utils/evolution_offer_utils.py",
    "name": "generate_evolution_offer_for_actor",
    "lineno": 27,
    "args": [
      "actor",
      "technique_id"
    ],
    "doc": "Generates 4 weighted mutation offers for a given actor's visible technique.\n\nReturns list of offer dicts:\n    - type\n    - skill\n    - technique\n    - value",
    "calls": [
      "ValueError",
      "append",
      "choice",
      "choices",
      "generate_evolution_offer",
      "get",
      "get_allowed_rarities",
      "keys",
      "list",
      "min",
      "range",
      "values"
    ],
    "called_by": [
      "handle_post_action_mutation"
    ]
  },
  {
    "module": "utils/general_utils.py",
    "name": "validate_tags",
    "lineno": 12,
    "args": [
      "defs",
      "kind"
    ],
    "doc": "Validates that all tags in a given definition dict exist in TAG_DB.",
    "calls": [
      "ValueError",
      "get",
      "items",
      "set"
    ],
    "called_by": [
      "validate_all_tags"
    ]
  },
  {
    "module": "utils/general_utils.py",
    "name": "validate_all_tags",
    "lineno": 23,
    "args": [
      "skill_defs",
      "technique_defs"
    ],
    "doc": "Runs tag validation on both skills and techniques.",
    "calls": [
      "validate_tags"
    ],
    "called_by": []
  },
  {
    "module": "utils/general_utils.py",
    "name": "trace_line",
    "lineno": 31,
    "args": [
      "start",
      "end",
      "floorplan",
      "stop_at_block"
    ],
    "doc": "Traces a straight line from `start` to `end` using a grid-based algorithm.\nReturns a list of dicts, one for each tile crossed, including blocking status.\n\nThis function does NOT interpret what counts as blocking \u2014 it marks the presence\nof potentially blocking features (terrain, things), but leaves interpretation\nto the caller.\n\nParameters:\n    - start: origin (x, y)\n    - end: destination (x, y)\n    - floorplan: map of (x, y) to tile dict\n    - stop_at_block: if True, halts trace when blocking tile is encountered\n\nDesign constraints:\n- No side effects (pure function)\n- Supports cardinal and diagonal directions\n- Does not skip corners\n- Assumes floorplan is prevalidated and includes full tile data for every coord",
    "calls": [
      "abs",
      "append",
      "bresenham_line",
      "get"
    ],
    "called_by": [
      "test_diagonal_line_with_blocking_tile",
      "test_missing_env_field",
      "test_missing_tile_skipped",
      "test_multiple_penalty_sources",
      "test_no_environment_penalty",
      "test_single_fog_tile",
      "test_straight_line_unblocked",
      "test_tile_with_blocking_thing"
    ]
  },
  {
    "module": "utils/general_utils.py",
    "name": "compute_visibility_penalty_along_path",
    "lineno": 121,
    "args": [
      "traced_path"
    ],
    "doc": "Given a traced path from `trace_line`, compute the cumulative visibility penalty\nfrom all environmental effects (e.g. fog, smoke, fire) on traversed tiles.\n\nThis function does not alter the path or interpret vision outcomes \u2014 it merely\nreturns the total penalty value for further evaluation.",
    "calls": [
      "get"
    ],
    "called_by": [
      "test_empty_path",
      "test_env_not_list",
      "test_invalid_path_type",
      "test_missing_env_field",
      "test_missing_tile_dict",
      "test_multiple_penalty_sources",
      "test_no_environment_penalty",
      "test_single_fog_tile",
      "test_step_not_dict"
    ]
  },
  {
    "module": "utils/general_utils.py",
    "name": "bresenham_line",
    "lineno": 58,
    "args": [
      "x0",
      "y0",
      "x1",
      "y1"
    ],
    "doc": "Bresenham's line algorithm (integer-based, grid-safe)",
    "calls": [
      "abs",
      "append"
    ],
    "called_by": [
      "trace_line"
    ]
  },
  {
    "module": "utils/initiative_queue.py",
    "name": "initialize_initiative_queue",
    "lineno": 4,
    "args": [
      "actors"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/initiative_queue.py",
    "name": "pop_next_actor",
    "lineno": 6,
    "args": [],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/initiative_queue.py",
    "name": "schedule_next_turn",
    "lineno": 8,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/inventory_utils.py",
    "name": "add_item_to_inventory",
    "lineno": 4,
    "args": [
      "actor",
      "item"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/inventory_utils.py",
    "name": "remove_item_from_inventory",
    "lineno": 6,
    "args": [
      "actor",
      "item"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/inventory_utils.py",
    "name": "is_item_usable",
    "lineno": 8,
    "args": [
      "actor",
      "item"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/loot_utils.py",
    "name": "roll_loot_table",
    "lineno": 4,
    "args": [
      "source"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/loot_utils.py",
    "name": "drop_loot_to_room",
    "lineno": 6,
    "args": [
      "room",
      "items"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/movement_utils.py",
    "name": "move_actor_to_zone",
    "lineno": 28,
    "args": [
      "actor",
      "destination_zone"
    ],
    "doc": "\ud83d\udeb6 Low-level zone transition function. Moves an actor from their current\nzone to an *adjacent* zone, with full validation.\n\nThis is the core atomic movement step, and is used by all higher-level\nmovement logic. It ensures:\n- The destination zone is adjacent to the current one\n- The actor is removed from the old zone and added to the new one\n- The actor's `current_zone` reference is updated\n\nParameters:\n- actor: any object with `.name` and `.current_zone`\n- destination_zone: Zone object\n\nReturns:\n- True if move succeeds\n- False if destination is not adjacent",
    "calls": [
      "append",
      "debug",
      "remove"
    ],
    "called_by": [
      "advance_actor_movement",
      "move_actor_toward_target"
    ]
  },
  {
    "module": "utils/movement_utils.py",
    "name": "get_zone_by_feature",
    "lineno": 68,
    "args": [
      "room",
      "feature_string"
    ],
    "doc": "Resolves a string like \"broken pillar\" or \"pile of crates\"\nto the first Zone in the room that contains that feature.\n\nParameters:\n- room: Room object containing zones\n- feature_string: exact string to match in zone.features\n\nReturns:\n- Zone object if found\n- None if not found",
    "calls": [
      "debug",
      "values"
    ],
    "called_by": [
      "resolve_target_to_zone"
    ]
  },
  {
    "module": "utils/movement_utils.py",
    "name": "resolve_target_to_zone",
    "lineno": 88,
    "args": [
      "target",
      "room"
    ],
    "doc": "Resolves any navigation target to a Zone.\n\nAccepted target types:\n- str: treated as a feature name\n- any object with `.current_zone`: treated as an actor\n\nParameters:\n- target: str or actor object\n- room: Room object used for feature resolution\n\nReturns:\n- Zone object or None",
    "calls": [
      "debug",
      "get_zone_by_feature",
      "hasattr",
      "isinstance",
      "type"
    ],
    "called_by": [
      "move_actor_toward_target",
      "start_movement_to_target"
    ]
  },
  {
    "module": "utils/movement_utils.py",
    "name": "find_path_between_zones",
    "lineno": 114,
    "args": [
      "start_zone",
      "target_zone"
    ],
    "doc": "Returns a list of zones connecting start_zone to target_zone\nusing breadth-first search.\n\nThis allows navigation across multi-zone rooms based on connectivity.\n\nReturns:\n- List of Zone objects [start, ..., target]\n- Empty list if no valid path exists",
    "calls": [
      "add",
      "append",
      "debug",
      "deque",
      "popleft",
      "set"
    ],
    "called_by": [
      "move_actor_toward_target",
      "start_movement_to_target"
    ]
  },
  {
    "module": "utils/movement_utils.py",
    "name": "distance_between_zones",
    "lineno": 150,
    "args": [
      "start_zone",
      "target_zone"
    ],
    "doc": "Returns the number of hops between two zones using breadth-first search.\nIf no path exists (e.g. blocked or disconnected), returns None.",
    "calls": [
      "add",
      "append",
      "deque",
      "popleft",
      "set"
    ],
    "called_by": [
      "observe"
    ]
  },
  {
    "module": "utils/movement_utils.py",
    "name": "move_actor_toward_target",
    "lineno": 179,
    "args": [
      "actor",
      "room",
      "target"
    ],
    "doc": "Generalized movement function that handles:\n- Moving toward a feature (str)\n- Moving toward another actor\n\nIt resolves the target to a destination zone, computes the shortest\npath from the actor's current zone, and moves one step toward it.\n\nThis enables natural language-style inputs:\n- \"move to pile of crates\"\n- \"approach the automaton\"\n\nMovement is only one step per call to enforce tactical pacing.\n\nParameters:\n- actor: object with .name and .current_zone\n- room: Room object the actor is in\n- target: str (feature) or object with .current_zone\n\nReturns:\n- True if movement occurred\n- False if move invalid, unreachable, or already there",
    "calls": [
      "debug",
      "find_path_between_zones",
      "len",
      "move_actor_to_zone",
      "resolve_target_to_zone"
    ],
    "called_by": []
  },
  {
    "module": "utils/movement_utils.py",
    "name": "start_movement_to_target",
    "lineno": 220,
    "args": [
      "actor",
      "room",
      "target"
    ],
    "doc": "Initializes multi-turn movement toward a feature or actor.\nStores the zone path in actor.movement_path.\n\nThis replaces immediate movement \u2014 nothing happens this turn,\nbut actor is now committed to a path.\n\nParameters:\n- actor: actor object\n- room: the current Room\n- target: feature string or another actor\n\nReturns:\n- True if movement path created\n- False if target invalid or unreachable",
    "calls": [
      "debug",
      "find_path_between_zones",
      "len",
      "resolve_target_to_zone"
    ],
    "called_by": []
  },
  {
    "module": "utils/movement_utils.py",
    "name": "advance_actor_movement",
    "lineno": 252,
    "args": [
      "actor"
    ],
    "doc": "Advances movement along actor's movement_path by one turn.\n- Adds 1 to progress\n- Moves to next zone when cost is met\n- Resets progress\n- Continues until path is empty\n\nReturns:\n- True if actor moved to a new zone this turn\n- False if still progressing or path empty",
    "calls": [
      "debug",
      "move_actor_to_zone",
      "pop"
    ],
    "called_by": []
  },
  {
    "module": "utils/npc_ai.py",
    "name": "handle_npc_action",
    "lineno": 4,
    "args": [
      "npc"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/npc_ai.py",
    "name": "choose_npc_action",
    "lineno": 6,
    "args": [
      "npc"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/npc_ai.py",
    "name": "npc_can_see_player",
    "lineno": 8,
    "args": [
      "npc",
      "player"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/skills_utils.py",
    "name": "tick_skill_progression",
    "lineno": 4,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/skills_utils.py",
    "name": "get_skill_modifier",
    "lineno": 6,
    "args": [
      "actor",
      "skill_tag"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/skills_utils.py",
    "name": "add_skill_xp",
    "lineno": 8,
    "args": [
      "actor",
      "tag",
      "amount"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/skill_xp_utils.py",
    "name": "track_xp_gain",
    "lineno": 7,
    "args": [
      "actor",
      "tags"
    ],
    "doc": "Distributes XP to matching skills and techniques.\n\nAutomatically initializes skills/techniques if needed.\n\nXP gain is flat per success. Level-up is probabilistic.",
    "calls": [
      "_check_level_up",
      "_tags_match",
      "get",
      "getattr",
      "initialize_skill_if_missing",
      "initialize_technique_if_missing",
      "items"
    ],
    "called_by": [
      "run_action_phase"
    ]
  },
  {
    "module": "utils/skill_xp_utils.py",
    "name": "_tags_match",
    "lineno": 45,
    "args": [
      "observed",
      "required"
    ],
    "doc": "Returns True if any of the required tags are found in the observed list.",
    "calls": [
      "any"
    ],
    "called_by": [
      "track_xp_gain"
    ]
  },
  {
    "module": "utils/skill_xp_utils.py",
    "name": "_check_level_up",
    "lineno": 56,
    "args": [
      "block"
    ],
    "doc": "Performs a probabilistic level-up check for the given skill or technique block.\nXP is preserved. Visibility is granted on first level.",
    "calls": [
      "get"
    ],
    "called_by": [
      "track_xp_gain"
    ]
  },
  {
    "module": "utils/status_effects.py",
    "name": "apply_status_effects",
    "lineno": 4,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/status_effects.py",
    "name": "tick_status_effects",
    "lineno": 6,
    "args": [
      "actor"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/status_effects.py",
    "name": "add_effect",
    "lineno": 8,
    "args": [
      "actor",
      "effect_dict"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/technique_mutation_utils.py",
    "name": "generate_evolution_offer",
    "lineno": 12,
    "args": [
      "base_technique",
      "rarity"
    ],
    "doc": "Given a technique dict, returns 4 possible evolution choices:\n- Add effect (if legal)\n- Replace effect\n- Change modifier (if any)\n- Bank offer\n\nThe rarity parameter influences the subcomponent weights.",
    "calls": [
      "append",
      "available_effects",
      "choice",
      "copy",
      "get",
      "len"
    ],
    "called_by": [
      "generate_evolution_offer_for_actor",
      "get_mutation_offer"
    ]
  },
  {
    "module": "utils/technique_mutation_utils.py",
    "name": "apply_mutation",
    "lineno": 62,
    "args": [
      "base_technique",
      "offer"
    ],
    "doc": "Applies the selected mutation offer to the base technique.\n\nArguments:\n    base_technique: The original technique dict before mutation.\n    offer: A dict containing keys:\n        - \"type\": One of \"replace_effect\", \"add_effect\", \"change_modifier\", \"bank\"\n        - \"result\": The precomputed result technique (except for \"bank\")\n\nReturns:\n    A new technique dict reflecting the chosen mutation.\n    If type == \"bank\", returns the original technique unchanged.",
    "calls": [
      "ValueError"
    ],
    "called_by": [
      "apply_mutation_to_actor"
    ]
  },
  {
    "module": "utils/technique_mutation_utils.py",
    "name": "available_effects",
    "lineno": 25,
    "args": [
      "existing"
    ],
    "doc": "",
    "calls": [],
    "called_by": [
      "generate_evolution_offer"
    ]
  },
  {
    "module": "utils/technique_unlock_utils.py",
    "name": "auto_unlock_techniques",
    "lineno": 7,
    "args": [
      "actor"
    ],
    "doc": "Scans canonical techniques and adds any to the actor whose\nbase_skill has reached its level_required.",
    "calls": [
      "add_technique",
      "get",
      "int",
      "items"
    ],
    "called_by": [
      "run_action_phase"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "generate_technique",
    "lineno": 12,
    "args": [
      "skill_id"
    ],
    "doc": "Generate a base technique scaffold with random components for a given skill.",
    "calls": [
      "choice",
      "keys",
      "list"
    ],
    "called_by": [
      "_generate_base_technique"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "evolve_replace_effect",
    "lineno": 36,
    "args": [
      "tech"
    ],
    "doc": "Replaces the first effect with a different one from the effect pool.\nGuarantees a change if at least 2 effects exist.\nSkips if same replacement already applied.",
    "calls": [
      "append",
      "choice",
      "get",
      "keys",
      "list",
      "setdefault"
    ],
    "called_by": [
      "evolve_technique"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "evolve_add_modifier",
    "lineno": 69,
    "args": [
      "tech",
      "options"
    ],
    "doc": "Adds a new modifier from the pool. Does nothing if already added.",
    "calls": [
      "append",
      "choice",
      "get",
      "setdefault"
    ],
    "called_by": [
      "evolve_technique"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "evolve_add_effect",
    "lineno": 91,
    "args": [
      "tech",
      "options"
    ],
    "doc": "Adds a new effect if not already present and not already added before.",
    "calls": [
      "append",
      "choice",
      "get",
      "len",
      "setdefault"
    ],
    "called_by": [
      "evolve_technique"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "evolve_technique",
    "lineno": 122,
    "args": [
      "tech",
      "mode",
      "options"
    ],
    "doc": "Dispatches to the correct mutation function for test scaffolding.\nNot intended for runtime use.",
    "calls": [
      "ValueError",
      "evolve_add_effect",
      "evolve_add_modifier",
      "evolve_replace_effect"
    ],
    "called_by": [
      "generate_evolution_offer"
    ]
  },
  {
    "module": "utils/technique_utils.py",
    "name": "get_available_mutations",
    "lineno": 141,
    "args": [
      "tech"
    ],
    "doc": "Returns a list of valid mutation types for a given technique.\n\nEnsures we do not suggest evolutions that would exceed field limits\nor create invalid states. Used by the mutation offer generator.\n\nPossible mutations:\n- \"replace_effect\": always allowed if any effect exists\n- \"add_effect\": allowed if len(effects) < 2\n- \"add_modifier\": only allowed if modifier is None",
    "calls": [
      "append",
      "get",
      "len"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_trace_line.py",
    "name": "make_blank_tile",
    "lineno": 6,
    "args": [],
    "doc": "",
    "calls": [],
    "called_by": [
      "test_diagonal_line_with_blocking_tile",
      "test_missing_tile_skipped",
      "test_straight_line_unblocked",
      "test_tile_with_blocking_thing"
    ]
  },
  {
    "module": "utils/test_trace_line.py",
    "name": "test_straight_line_unblocked",
    "lineno": 9,
    "args": [],
    "doc": "",
    "calls": [
      "all",
      "make_blank_tile",
      "range",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_trace_line.py",
    "name": "test_diagonal_line_with_blocking_tile",
    "lineno": 17,
    "args": [],
    "doc": "",
    "calls": [
      "make_blank_tile",
      "range",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_trace_line.py",
    "name": "test_tile_with_blocking_thing",
    "lineno": 27,
    "args": [],
    "doc": "",
    "calls": [
      "append",
      "make_blank_tile",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_trace_line.py",
    "name": "test_missing_tile_skipped",
    "lineno": 34,
    "args": [],
    "doc": "",
    "calls": [
      "make_blank_tile",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "make_tile_with_env",
    "lineno": 6,
    "args": [
      "penalties"
    ],
    "doc": "Helper: create tile with list of env objects, each with a visibility_penalty.",
    "calls": [
      "enumerate"
    ],
    "called_by": [
      "test_missing_env_field",
      "test_multiple_penalty_sources",
      "test_single_fog_tile"
    ]
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_no_environment_penalty",
    "lineno": 14,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "range",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_single_fog_tile",
    "lineno": 19,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "make_tile_with_env",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_multiple_penalty_sources",
    "lineno": 28,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "make_tile_with_env",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_missing_env_field",
    "lineno": 37,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "make_tile_with_env",
      "trace_line"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_empty_path",
    "lineno": 46,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_invalid_path_type",
    "lineno": 49,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "raises"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_step_not_dict",
    "lineno": 53,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "raises"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_missing_tile_dict",
    "lineno": 57,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "raises"
    ],
    "called_by": []
  },
  {
    "module": "utils/test_visibility_penalty.py",
    "name": "test_env_not_list",
    "lineno": 61,
    "args": [],
    "doc": "",
    "calls": [
      "compute_visibility_penalty_along_path",
      "raises"
    ],
    "called_by": []
  },
  {
    "module": "utils/visibility_utils.py",
    "name": "get_visibility_caps",
    "lineno": 8,
    "args": [
      "light_level"
    ],
    "doc": "Returns (max_clear, max_vague) based on light level.\nIncludes overexposure collapse at high intensity.",
    "calls": [],
    "called_by": [
      "observe"
    ]
  },
  {
    "module": "utils/visibility_utils.py",
    "name": "visual_coverage",
    "lineno": 37,
    "args": [
      "observer_zone",
      "target_zone"
    ],
    "doc": "Estimate how much of the target zone is visible from the observer.\nUses number of blocking zones along the visibility path as a proxy for visual obstruction.\n\nReturns a float between 0.0 and 1.0:\n- >= 0.9 \u2192 clear visibility\n- >= 0.3 \u2192 vague\n- < 0.3 \u2192 unseen",
    "calls": [
      "len",
      "trace_visibility_path"
    ],
    "called_by": [
      "observe"
    ]
  },
  {
    "module": "utils/visibility_utils.py",
    "name": "observe",
    "lineno": 59,
    "args": [
      "observer"
    ],
    "doc": "Perception scan with:\n- Light-based visibility caps\n- Vague fallback awareness\n- Tiered resolution: clear, vague, or unknown",
    "calls": [
      "append",
      "debug",
      "distance_between_zones",
      "get",
      "get_visibility_caps",
      "getattr",
      "max",
      "trace_visibility_path",
      "visual_coverage"
    ],
    "called_by": []
  },
  {
    "module": "utils/visibility_utils.py",
    "name": "trace_visibility_path",
    "lineno": 150,
    "args": [
      "origin",
      "target"
    ],
    "doc": "Returns the list of intermediate zones (excluding origin and target)\nalong the shortest line-of-vision path between origin and target.\nThis is a vision-safe BFS path that ignores movement-specific obstacles.\n\nIf no path is found (e.g. disconnected zones), returns None.",
    "calls": [
      "add",
      "append",
      "deque",
      "popleft",
      "set"
    ],
    "called_by": [
      "observe",
      "visual_coverage"
    ]
  },
  {
    "module": "utils/visibility_utils.py",
    "name": "compute_visibility_penalty_along_path",
    "lineno": 182,
    "args": [
      "traced_path"
    ],
    "doc": "",
    "calls": [
      "TypeError",
      "get",
      "isinstance"
    ],
    "called_by": [
      "test_empty_path",
      "test_env_not_list",
      "test_invalid_path_type",
      "test_missing_env_field",
      "test_missing_tile_dict",
      "test_multiple_penalty_sources",
      "test_no_environment_penalty",
      "test_single_fog_tile",
      "test_step_not_dict"
    ]
  },
  {
    "module": "utils/world_utils.py",
    "name": "get_all_actors_in_room",
    "lineno": 4,
    "args": [
      "room"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/world_utils.py",
    "name": "remove_dead_entities",
    "lineno": 6,
    "args": [],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "utils/world_utils.py",
    "name": "transfer_loot_to_room",
    "lineno": 8,
    "args": [
      "npc"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/discovery.py",
    "name": "__init__",
    "lineno": 8,
    "args": [
      "self",
      "type",
      "faction",
      "seed"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/discovery.py",
    "name": "reveal",
    "lineno": 15,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [
      "instantiate"
    ],
    "called_by": []
  },
  {
    "module": "world/discovery.py",
    "name": "instantiate",
    "lineno": 19,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [
      "LocationInstance"
    ],
    "called_by": [
      "reveal"
    ]
  },
  {
    "module": "world/discovery.py",
    "name": "__init__",
    "lineno": 24,
    "args": [
      "self",
      "type",
      "seed"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/discovery.py",
    "name": "generate_floorplan",
    "lineno": 32,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/discovery.py",
    "name": "teardown",
    "lineno": 35,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/generation.py",
    "name": "__init__",
    "lineno": 8,
    "args": [
      "self",
      "world_seed"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  },
  {
    "module": "world/generation.py",
    "name": "generate_tile",
    "lineno": 11,
    "args": [
      "self",
      "tile",
      "neighbors"
    ],
    "doc": "",
    "calls": [
      "sample_biome",
      "sample_elevation",
      "sample_features",
      "sample_moisture"
    ],
    "called_by": []
  },
  {
    "module": "world/generation.py",
    "name": "sample_biome",
    "lineno": 18,
    "args": [
      "self",
      "tile",
      "neighbors"
    ],
    "doc": "",
    "calls": [],
    "called_by": [
      "generate_tile"
    ]
  },
  {
    "module": "world/generation.py",
    "name": "sample_elevation",
    "lineno": 21,
    "args": [
      "self",
      "tile",
      "neighbors"
    ],
    "doc": "",
    "calls": [],
    "called_by": [
      "generate_tile"
    ]
  },
  {
    "module": "world/generation.py",
    "name": "sample_moisture",
    "lineno": 24,
    "args": [
      "self",
      "tile",
      "neighbors"
    ],
    "doc": "",
    "calls": [],
    "called_by": [
      "generate_tile"
    ]
  },
  {
    "module": "world/generation.py",
    "name": "sample_features",
    "lineno": 27,
    "args": [
      "self",
      "tile",
      "neighbors"
    ],
    "doc": "",
    "calls": [],
    "called_by": [
      "generate_tile"
    ]
  },
  {
    "module": "world/hex.py",
    "name": "__init__",
    "lineno": 8,
    "args": [
      "self",
      "q",
      "r",
      "seed"
    ],
    "doc": "",
    "calls": [
      "generate_seed"
    ],
    "called_by": []
  },
  {
    "module": "world/hex.py",
    "name": "generate_seed",
    "lineno": 20,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [
      "hash"
    ],
    "called_by": [
      "__init__"
    ]
  },
  {
    "module": "world/hex.py",
    "name": "coord",
    "lineno": 23,
    "args": [
      "self"
    ],
    "doc": "",
    "calls": [],
    "called_by": []
  }
]